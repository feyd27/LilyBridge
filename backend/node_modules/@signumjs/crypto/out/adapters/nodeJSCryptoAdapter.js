"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeJSCryptoAdapter = void 0;
const base_1 = require("../base");
const cryptoError_1 = require("../typings/cryptoError");
class NodeJSCryptoAdapter {
    crypto;
    constructor() {
        this.crypto = require('crypto');
    }
    getRandomValues(array) {
        return this.crypto.randomFillSync(array);
    }
    async decryptAes256Cbc(ciphertext, key) {
        return new Promise((resolve, reject) => {
            try {
                const iv = ciphertext.slice(0, base_1.CryptoParams.IvLength); // Assuming IvLength is 16
                const encryptedText = ciphertext.slice(base_1.CryptoParams.IvLength);
                const decipher = this.crypto.createDecipheriv('aes-256-cbc', key, iv);
                let decrypted = decipher.update(encryptedText);
                decrypted = Buffer.concat([decrypted, decipher.final()]);
                resolve(new Uint8Array(decrypted));
            }
            catch (e) {
                // @ts-ignore
                reject(new cryptoError_1.CryptoError(e.message));
            }
        });
    }
    async encryptAes256Cbc(plaintext, key) {
        return new Promise((resolve, reject) => {
            try {
                const iv = this.getRandomValues(new Uint8Array(base_1.CryptoParams.IvLength));
                const cipher = this.crypto.createCipheriv('aes-256-cbc', key, iv);
                let encrypted = cipher.update(plaintext);
                encrypted = Buffer.concat([encrypted, cipher.final()]);
                const ivAndCiphertext = new Uint8Array(iv.length + encrypted.length);
                ivAndCiphertext.set(iv);
                ivAndCiphertext.set(new Uint8Array(encrypted), iv.length);
                resolve(ivAndCiphertext);
            }
            catch (e) {
                // @ts-ignore
                reject(new cryptoError_1.CryptoError(e.message));
            }
        });
    }
    sha256(data) {
        const hash = this.crypto.createHash('SHA256').update(Buffer.from(data)).digest();
        return new Uint8Array(hash);
    }
}
exports.NodeJSCryptoAdapter = NodeJSCryptoAdapter;
//# sourceMappingURL=nodeJSCryptoAdapter.js.map