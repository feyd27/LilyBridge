"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpMockBuilder = void 0;
const httpResponse_1 = require("./httpResponse");
const httpError_1 = require("./httpError");
class HttpMock {
    static ForAll = '__all';
    constructor() {
        this.reset();
    }
    _replyFunctions = HttpMock.initialReplyFunctions();
    static initialReplyFunctions() {
        return {
            get: {},
            post: {},
            put: {},
            delete: {}
        };
    }
    createReplyFn(status, data) {
        return () => Promise.resolve(new httpResponse_1.HttpResponse(status, data));
    }
    createErrorFn(requestUrl, status, message, data = null) {
        return () => {
            throw new httpError_1.HttpError(requestUrl, status, message, data);
        };
    }
    reset() {
        this._replyFunctions = HttpMock.initialReplyFunctions();
    }
    registerResponse(method, url, status, data) {
        // @ts-ignore
        this._replyFunctions[method][url] = this.createReplyFn(status, data);
    }
    registerError(method, url, status, message, data) {
        // @ts-ignore
        this._replyFunctions[method][url] = this.createErrorFn(url, status, message, data);
    }
    get(url) {
        return this.request('get', url);
    }
    delete(url) {
        return this.request('delete', url);
    }
    post(url, payload) {
        return this.request('post', url); // ignore payload...
    }
    put(url, payload) {
        return this.request('put', url); // ignore payload...
    }
    request(method, url) {
        // @ts-ignore
        const replyFn = this._replyFunctions[method][url] || this._replyFunctions[method][HttpMock.ForAll];
        if (!replyFn) {
            throw new Error(`Could not find any mocked function for method ${method.toUpperCase()} url ${url}`);
        }
        return replyFn();
    }
}
/**
 * Http Mocker Builder for easy to http testing
 *
 * Example:
 * ```
 const mockedHttp = HttpMockBuilder
 .create()
 .onGetReply(200, {foo: 'get'})
 .onPostThrowError(500, 'Post Error', {e: 'post'})
 .onPutThrowError(404, 'Put Error', {e: 'put'})
 .onDeleteThrowError(403, 'Delete Error', {e: 'delete'})
 .build();

 const response = await mockedHttp.get('/url');

 await mockedHttp.post('/url/post', {faz: 'post'}); // will throw exception

 * ```
 *
 * @module http
 */
class HttpMockBuilder {
    _httpMock;
    constructor() {
        this._httpMock = new HttpMock();
    }
    /**
     * Creates a builder instance
     * @return {HttpMockBuilder} the builder
     */
    static create() {
        return new HttpMockBuilder();
    }
    onReply(method, status, data, url = HttpMock.ForAll) {
        this._httpMock.registerResponse(method, url, status, data);
        return this;
    }
    onThrowError(method, status, errorMessage, data, url = HttpMock.ForAll) {
        this._httpMock.registerError(method, url, status, errorMessage, data);
        return this;
    }
    /**
     * Mocks responses for get methods
     * You may pass a specific endpoint as parameter to mock only selected endpoints.
     * This is very useful, when having methods that do several Http requests,
     * so you can mock them one on one.
     *
     * The following code returns the same content on _every_ get call
     * ```
     *   HttpMockBuilder
     *   .create()
     *   .onGetReply(200, {response: 'foo}) // mocks all get requests
     *   .onPostReply(201, {response: 'foo}) // mocks all post requests
     *   .build()
     * ```
     *
     *  The next code returns the different content depending on the passed endpoint
     * ```
     *   HttpMockBuilder
     *   .create()
     *   .onGetReply(200, {response: 'foo}, '/url/specific') // mocks get request for '/url/specific'
     *   .build()
     * ```
     * @param status {number} The status to be returned
     * @param data The data to be returned
     * @param url {string?} If given, the mock applies for that specific url, other for all method calls
     * @return {HttpMockBuilder} The builder instance (Fluent API)
     */
    onGetReply(status, data, url) {
        return this.onReply('get', status, data, url);
    }
    /**
     * Mocks response exceptions for get methods. It works like onGetReply(), but throws an HttpError instead
     * @param status {number} The status to be returned in exception object
     * @param errorMessage {string} The error message
     * @param data {any?} Eventual data carried with the error object
     * @param url {string?} The specific url for which the exception should be thrown
     * @return {HttpMockBuilder} The builder instance (Fluent API)
     */
    onGetThrowError(status, errorMessage, data = null, url = HttpMock.ForAll) {
        return this.onThrowError('get', status, errorMessage, data, url);
    }
    /**
     * Mocks post requests. Works analog to onGetReply().
     */
    onPostReply(status, data, url) {
        return this.onReply('post', status, data, url);
    }
    /**
     * Mocks response exceptions for post methods. It works like onPostReply(), but throws an HttpError instead
     */
    onPostThrowError(status, errorMessage, data, url = HttpMock.ForAll) {
        return this.onThrowError('post', status, errorMessage, data, url);
    }
    /**
     * Mocks put requests. Works analog to onGetReply().
     */
    onPutReply(status, data, url) {
        return this.onReply('put', status, data, url);
    }
    /**
     * Mocks response exceptions for put methods. It works like onPutReply(), but throws an HttpError instead
     */
    onPutThrowError(status, errorMessage, data, url = HttpMock.ForAll) {
        return this.onThrowError('put', status, errorMessage, data, url);
    }
    /**
     * Mocks delete requests. Works analog to onGetReply().
     */
    onDeleteReply(status, data, url) {
        return this.onReply('delete', status, data, url);
    }
    /**
     * Mocks response exceptions for delete methods. It works like onDeleteReply(), but throws an HttpError instead
     */
    onDeleteThrowError(status, errorMessage, data, url = HttpMock.ForAll) {
        return this.onThrowError('delete', status, errorMessage, data, url);
    }
    /**
     * Builds the Http mock.
     * @return {Http} The mocked Http implementation
     */
    build() {
        return this._httpMock;
    }
}
exports.HttpMockBuilder = HttpMockBuilder;
//# sourceMappingURL=httpMockBuilder.js.map