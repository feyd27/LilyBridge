import { Http } from './http';
/**
 * Http Mocker Builder for easy to http testing
 *
 * Example:
 * ```
 const mockedHttp = HttpMockBuilder
 .create()
 .onGetReply(200, {foo: 'get'})
 .onPostThrowError(500, 'Post Error', {e: 'post'})
 .onPutThrowError(404, 'Put Error', {e: 'put'})
 .onDeleteThrowError(403, 'Delete Error', {e: 'delete'})
 .build();

 const response = await mockedHttp.get('/url');

 await mockedHttp.post('/url/post', {faz: 'post'}); // will throw exception

 * ```
 *
 * @module http
 */
export declare class HttpMockBuilder {
    private readonly _httpMock;
    private constructor();
    /**
     * Creates a builder instance
     * @return {HttpMockBuilder} the builder
     */
    static create(): HttpMockBuilder;
    private onReply;
    private onThrowError;
    /**
     * Mocks responses for get methods
     * You may pass a specific endpoint as parameter to mock only selected endpoints.
     * This is very useful, when having methods that do several Http requests,
     * so you can mock them one on one.
     *
     * The following code returns the same content on _every_ get call
     * ```
     *   HttpMockBuilder
     *   .create()
     *   .onGetReply(200, {response: 'foo}) // mocks all get requests
     *   .onPostReply(201, {response: 'foo}) // mocks all post requests
     *   .build()
     * ```
     *
     *  The next code returns the different content depending on the passed endpoint
     * ```
     *   HttpMockBuilder
     *   .create()
     *   .onGetReply(200, {response: 'foo}, '/url/specific') // mocks get request for '/url/specific'
     *   .build()
     * ```
     * @param status {number} The status to be returned
     * @param data The data to be returned
     * @param url {string?} If given, the mock applies for that specific url, other for all method calls
     * @return {HttpMockBuilder} The builder instance (Fluent API)
     */
    onGetReply(status: number, data: any, url?: string): HttpMockBuilder;
    /**
     * Mocks response exceptions for get methods. It works like onGetReply(), but throws an HttpError instead
     * @param status {number} The status to be returned in exception object
     * @param errorMessage {string} The error message
     * @param data {any?} Eventual data carried with the error object
     * @param url {string?} The specific url for which the exception should be thrown
     * @return {HttpMockBuilder} The builder instance (Fluent API)
     */
    onGetThrowError(status: number, errorMessage: string, data?: any, url?: string): HttpMockBuilder;
    /**
     * Mocks post requests. Works analog to onGetReply().
     */
    onPostReply(status: number, data: any, url?: string): HttpMockBuilder;
    /**
     * Mocks response exceptions for post methods. It works like onPostReply(), but throws an HttpError instead
     */
    onPostThrowError(status: number, errorMessage: string, data: any, url?: string): HttpMockBuilder;
    /**
     * Mocks put requests. Works analog to onGetReply().
     */
    onPutReply(status: number, data: any, url?: string): HttpMockBuilder;
    /**
     * Mocks response exceptions for put methods. It works like onPutReply(), but throws an HttpError instead
     */
    onPutThrowError(status: number, errorMessage: string, data: any, url?: string): HttpMockBuilder;
    /**
     * Mocks delete requests. Works analog to onGetReply().
     */
    onDeleteReply(status: number, data: any, url?: string): HttpMockBuilder;
    /**
     * Mocks response exceptions for delete methods. It works like onDeleteReply(), but throws an HttpError instead
     */
    onDeleteThrowError(status: number, errorMessage: string, data: any, url?: string): HttpMockBuilder;
    /**
     * Builds the Http mock.
     * @return {Http} The mocked Http implementation
     */
    build(): Http;
}
