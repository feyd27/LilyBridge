"use strict";
/**
 * Copyright (c) 2019 Burst Apps Team
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractDataView = void 0;
const util_1 = require("@signumjs/util");
const getContractDatablock_1 = require("./getContractDatablock");
const countCodePages_1 = require("./countCodePages");
/**
 * Helper class for contracts
 *
 * A contract owns additional data, which is split in 8 byte blocks.
 * The content is encoded in hexadecimal representation and big endianness.
 * This class facilitates access to these data. The term "index" is used to address
 * these 8 byte blocks
 *
 * @example
 * A contract may have the following data
 *
 * ```
 * 010000000000000000e1f5050000000000000000000000003eba832d8f2c82fe0048e80100000000
 * ```
 *
 * Then it can be split into five data sections each 8 bytes (16 chars in hex) and indexed like shown
 *
 * ```
 * 0100000000000000 00e1f50500000000 0000000000000000 3eba832d8f2c82fe 0048e80100000000
 *
 * |------ 0 ------|------ 1 -------|------ 2 -------|------ 3 -------|------ 4 ------| = Indices
 *
 * ```
 *
 * @example Usage
 *
 * ```ts
 * const client = LedgerClientFactory.createClient({nodehost: "https://europe.signum.network"});
 * const nft = await client.contracts.getContract("9482276719950823724");
 * const dataView - new ContractDataView(nft);
 * const ownerId = dataView.getVariableAsDecimal(0);
 * const currentPrice = Amount.fromPlanck(dataview.getVariableAsDecimal(2));
 * ```
 *
 */
class ContractDataView {
    _contract;
    /**
     * The length of a contracts variable (considering Hex notation)
     */
    static VariableLength = 16;
    constructor(_contract) {
        this._contract = _contract;
    }
    /**
     * @return Get the contract
     */
    getContract() {
        return this._contract;
    }
    /**
     * @return The number of code pages
     */
    countCodePages() {
        return (0, countCodePages_1.countCodePages)(this._contract.machineCode);
    }
    /**
     * Get a variable as string
     * @param index The index of variable (starting at 0)
     * @return The data as string (Utf-8)
     */
    getVariableAsString(index) {
        const hexData = this.getHexDataAt(index, ContractDataView.VariableLength);
        return (0, util_1.convertHexStringToString)(hexData.replace(/00/g, ''));
    }
    /**
     * Get multiple data blocks as string
     * @param index The index of variable (starting at 0)
     * @param count Number of blocks
     * @return The data as string (Utf-8)
     */
    getDataBlocksAsString(index, count) {
        const hexData = this.getHexDataAt(index, count * ContractDataView.VariableLength);
        return (0, util_1.convertHexStringToString)(hexData.replace(/00/g, ''));
    }
    /**
     * Get a variable as decimal (string)
     * @param index The index of variable (starting at 0)
     * @return The data as a decimal string sequence
     */
    getVariableAsDecimal(index) {
        return (0, util_1.convertHexStringToDecString)(this.getVariable(index));
    }
    /**
     * Get a variable at given position/index
     * @param index The index of variable (starting at 0)
     * @return The data as hexadecimal string (in little endianness)
     */
    getVariable(index) {
        return this.getHexDataAt(index, ContractDataView.VariableLength);
    }
    /**
     * Get a hexadecimal data block of arbitrary length at given position/index
     * @param index The index of variable (starting at 0)
     * @param length The length of the data block (must be a multiple of 2)
     * @return The data as hexadecimal string (in little endianness)
     */
    getHexDataAt(index, length) {
        const l = length ? length : this._contract.machineData.length - ContractDataView.VariableLength * index;
        return (0, getContractDatablock_1.getContractDatablock)(this._contract, index, l);
    }
}
exports.ContractDataView = ContractDataView;
//# sourceMappingURL=ContractDataView.js.map