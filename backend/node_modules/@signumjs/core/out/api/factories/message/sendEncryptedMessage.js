"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendEncryptedMessage = void 0;
/**
 * Copyright (c) 2019 Burst Apps Team
 */
const crypto_1 = require("@signumjs/crypto");
const constants_1 = require("../../../constants");
const signIfPrivateKey_1 = require("../../../internal/signIfPrivateKey");
const MAX_MESSAGE_LENGTH = 1024;
/**
 * Use with {@link ApiComposer} and belongs to {@link MessageApi}.
 *
 * See details at {@link MessageApi.sendEncryptedMessage}
*
* @category factories
*/
const sendEncryptedMessage = (service) => (args) => (0, signIfPrivateKey_1.signIfPrivateKey)(service, args, async (a) => {
    const encryptedMessage = await (0, crypto_1.encryptMessage)(a.message, a.recipientPublicKey, a.senderAgreementKey);
    if (encryptedMessage.data.length > MAX_MESSAGE_LENGTH) {
        throw new Error(`The encrypted message exceeds allowed limit of ${MAX_MESSAGE_LENGTH} bytes`);
    }
    const parameters = {
        deadline: a.deadline || constants_1.DefaultDeadline,
        encryptedMessageData: encryptedMessage.data,
        encryptedMessageNonce: encryptedMessage.nonce,
        feeNQT: a.feePlanck,
        messageToEncryptIsText: a.messageIsText === undefined ? true : a.messageIsText,
        publicKey: a.senderPublicKey,
        recipient: a.recipientId,
        recipientPublicKey: a.recipientPublicKey || undefined,
        referencedTransactionFullHash: a.referencedTransactionFullHash || undefined
    };
    return service.send('sendMessage', parameters);
});
exports.sendEncryptedMessage = sendEncryptedMessage;
//# sourceMappingURL=sendEncryptedMessage.js.map