/**
 * Copyright (c) 2019 Burst Apps Team
 */
import { ChainService } from '../service';
import { Api } from '../typings/api';
/**
 * The API composer mounts the API for given service and selected methods
 *
 * Usually you would use{@link LedgerClientFactory} (or older style {@link composeApi}), which gives you _all_ available API methods.
 * Unfortunately, this will import almost all dependencies, even if you need only a fraction
 * of the methods. To take advantage of tree-shaking (dead code elimination) you can
 * compose your own API with the methods you need. This can reduce your final bundle significantly.
 *
 * Usage:
 * ```typescript
 *
 * const chainService = new ChainService({
 *     nodeHost: 'https://testnet.burst.fun',
 * })
 *
 * const api = apiComposer
 * .create(chainService)
 * .withMessageApi({
 *                sendTextMessage
 *            })
 * .withAccountApi({
 *                getAccountTransactions,
 *                getUnconfirmedAccountTransactions,
 *                getAccountBalance,
 *                generateSendTransactionQRCode,
 *                generateSendTransactionQRCodeAddress,
 *            })
 * .compose();
 * ```
 *
 * The `with<section>Api` uses factory methods from the [api.core.factories](/phoenix/docs/modules/core_api_factories.html) package
 *
 *
 * */
export declare class ApiComposer {
    private readonly service;
    private readonly api;
    /**
     * Creates the composer instance
     * @param service
     * @return the composer instance
     */
    static create(service: ChainService): ApiComposer;
    private constructor();
    private mapCreators;
    /**
     * Adds the {@link BlockApi} to be composed
     * @param creatorMap A map of creator/factory functions for the endpoints
     */
    withBlockApi(creatorMap: any): ApiComposer;
    /**
     * Adds the {@link AccountApi}  to be composed
     * @param creatorMap A map of creator/factory functions for the endpoints
     */
    withAccountApi(creatorMap: any): ApiComposer;
    /**
     * Adds the {@link NetworkApi}  to be composed
     * @param creatorMap A map of creator/factory functions for the endpoints
     */
    withNetworkApi(creatorMap: any): ApiComposer;
    /**
     * Adds the {@link MessageApi}  to be composed
     * @param creatorMap A map of creator/factory functions for the endpoints
     */
    withMessageApi(creatorMap: any): ApiComposer;
    /**
     * Adds the {@link TransactionApi}  to be composed
     * @param creatorMap A map of creator/factory functions for the endpoints
     */
    withTransactionApi(creatorMap: any): ApiComposer;
    /**
     * Adds the {@link AliasApi}  to be composed
     * @param creatorMap A map of creator/factory functions for the endpoints
     */
    withAliasApi(creatorMap: any): ApiComposer;
    /**
     * Adds the {@link AssetApi}  to be composed
     * @param creatorMap A map of creator/factory functions for the endpoints
     */
    withAssetApi(creatorMap: any): ApiComposer;
    /**
     * Adds the {@link ContractApi}  to be composed
     * @param creatorMap A map of creator/factory functions for the endpoints
     */
    withContractApi(creatorMap: any): ApiComposer;
    /**
     * Composes the API
     * Note: As of being a builder pattern, this need to call this method as last
     */
    compose(): Api;
}
