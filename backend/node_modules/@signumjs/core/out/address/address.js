"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Address = void 0;
/**
 * Original work Copyright (c) 2021 Burst Apps Team
 * Modified work Copyright (c) 2021 Signum Network
 */
const crypto_1 = require("@signumjs/crypto");
const util_1 = require("@signumjs/util");
const ensureReedSolomonAddress_1 = require("./ensureReedSolomonAddress");
const tokenizeReedSolomonAddress_1 = require("./tokenizeReedSolomonAddress");
const convertReedSolomonAddressToNumericId_1 = require("./convertReedSolomonAddressToNumericId");
const convertNumericIdToReedSolomonAddress_1 = require("./convertNumericIdToReedSolomonAddress");
const constants_1 = require("../constants");
function ensureValidPublicKey(publicKey) {
    if (!(publicKey && /^[a-fA-F0-9]{64}/.test(publicKey))) {
        throw new Error('Invalid Public Key Format');
    }
}
/**
 * A Value Object to facilitate Address conversions.
 *
 *
 */
class Address {
    _publicKey;
    _numericId;
    _rs;
    constructor(args) {
        if (args.publicKey) {
            this.constructFromPublicKey(args.publicKey, args.prefix);
        }
        else if (args.address) {
            this.constructFromAddress(args.address);
        }
        else {
            throw new Error('Invalid arguments');
        }
    }
    /**
     * Tries to create the address from whatever input is given
     * @param anyValidAddress Any valid address, may it be Reed Solomon address, numeric ID, or public key
     * @param prefix An optional prefix, which can be used to substitute the default {@link AddressPrefix.MainNet}
     * @return The new address, if the input was valid
     * @throws when no valid format
     */
    static create(anyValidAddress, prefix = constants_1.AddressPrefix.MainNet) {
        try {
            (0, tokenizeReedSolomonAddress_1.tokenizeReedSolomonAddress)(anyValidAddress);
            return Address.fromReedSolomonAddress(anyValidAddress);
            // @ts-ignore
        }
        catch (e) {
            try {
                ensureValidPublicKey(anyValidAddress);
                return Address.fromPublicKey(anyValidAddress, prefix);
            }
            catch (innerError) {
                return Address.fromNumericId(anyValidAddress, prefix);
            }
        }
    }
    static fromNumericId(numericId, prefix = constants_1.AddressPrefix.MainNet) {
        const address = (0, convertNumericIdToReedSolomonAddress_1.convertNumericIdToReedSolomonAddress)(numericId, prefix);
        return new Address({ address });
    }
    /**
     * Creates an Account Address object from public key
     * @param publicKey The public key of that address (in hex format)
     * @param prefix The Reed-Solomon Address prefix
     */
    static fromPublicKey(publicKey, prefix = constants_1.AddressPrefix.MainNet) {
        return new Address({ publicKey, prefix });
    }
    /**
     * Creates an Account Address object from extended Reed-Solomon address
     * @param address The Reed-Solomon address in simple or extended format (with base36 suffix)
     * @throws Error if the passed address is invalid
     */
    static fromReedSolomonAddress(address) {
        (0, ensureReedSolomonAddress_1.ensureReedSolomonAddress)(address);
        const { extension, prefix } = (0, tokenizeReedSolomonAddress_1.tokenizeReedSolomonAddress)(address);
        if (extension) {
            const publicKey = (0, util_1.convertBase36StringToHexString)(extension).toLowerCase();
            if ((0, convertReedSolomonAddressToNumericId_1.convertReedSolomonAddressToNumericId)(address) !== (0, crypto_1.getAccountIdFromPublicKey)(publicKey)) {
                throw Error('Address and Public Key do not match');
            }
            return new Address({ publicKey, prefix });
        }
        return new Address({ address });
    }
    /**
     * @return Gets public key
     */
    getPublicKey() {
        return this._publicKey.toLowerCase();
    }
    /**
     * @return Gets numeric Account Id
     */
    getNumericId() {
        return this._numericId;
    }
    /**
     * Gets as Reed Solomon representation
     * @param withPrefix If false, the address without prefix will be returned. Default: true
     * @return Reed Solomon Address Format
     * @see {@link Address.getReedSolomonAddressExtended}
     */
    getReedSolomonAddress(withPrefix = true) {
        return withPrefix ? this._rs : this._rs.substr(this._rs.indexOf('-') + 1);
    }
    /**
     * Gets as extended Reed Solomon representation carrying the public key as suffix in base36 encoding
     *
     * This method requires that the address was created from a public key or extended address.
     *
     * @param withPrefix If false, the address without prefix will be returned. Default: true
     * @return Extended Reed Solomon Address Format
     * @throws if no public key is available
     * @see {@link Address.getReedSolomonAddress}
     */
    getReedSolomonAddressExtended(withPrefix = true) {
        if (!this._publicKey) {
            throw new Error('No public key available');
        }
        return `${this.getReedSolomonAddress(withPrefix)}-${(0, util_1.convertHexStringToBase36String)(this._publicKey)}`.toUpperCase();
    }
    /**
     * Checks for equality
     * @param address The other address to be compared
     * @return true if equal, otherwise false
     */
    equals(address) {
        return this._numericId === address._numericId;
    }
    constructFromPublicKey(publicKey, prefix) {
        ensureValidPublicKey(publicKey);
        this._publicKey = publicKey.toLowerCase();
        this._numericId = (0, crypto_1.getAccountIdFromPublicKey)(publicKey);
        this._rs = (0, convertNumericIdToReedSolomonAddress_1.convertNumericIdToReedSolomonAddress)(this._numericId, prefix);
    }
    constructFromAddress(address) {
        this._publicKey = '';
        this._rs = address;
        this._numericId = (0, convertReedSolomonAddressToNumericId_1.convertReedSolomonAddressToNumericId)(address);
    }
}
exports.Address = Address;
//# sourceMappingURL=address.js.map